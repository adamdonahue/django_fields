We want to be able to generate a SQL statement of arbitrary complexity
based on a set of expressions.

We'll start with a single table (relation) and work through the kinks.

Some basic use cases:

SIMPLE SELECT
-------------

SELECT f0, ..., fn FROM t0;

This is easy; nature of problem defines f0, ..., fn as belonging to t0.

NON-WINDOW FUNCTIONS
--------------------

SELECT f0, ..., fn, F0(f0, ..., fn), ..., FN(f0, ..., fn) FROM t0;

Also relatively easy.  We can determine from F0, ..., FN which fields
each one needs and materialize as an expression.

GROUP EXPRESSIONS
-----------------

SELECT G(f0, ..., fj), fk, ..., fn FROM t0 GROUP BY fk, ..., fn;

NESTED GROUP EXPRESSIONS

SELECT H(G(...)) ... FROM t1 ...;

Here we want to do nested group-bys.  This generally requires a subselect,
which we can transform into a CTE.  If each G is represented as an expression,
and each H as an expression represented as needing another expression,
this gives us a tree of expressions we can use to generate a CTE hierarchy.

For example,

SELECT g1 + g2 / f3 AS h1 FROM (
    SELECT SUM(f1) AS g1, AVG(f2) AS g2, f3 FROM (
        SELECT f1, f2, f3 FROM t0
    ) AS t2 GROUP BY f3
);

can be rewritten as a set of CTEs:

WITH
t0 AS (
    SELECT f1, f2, f3 FROM t0
),
t1 AS (
    SELECT SUM(f1) AS g1, AVG(f2) AS g2, f3 FROM t0 GROUP BY f3
),
t2 AS (
    SELECT g1 + g2 / f3 AS h1 FROM t1
)
    SELECT h1 FROM t2;

And this can be generated by modeling the expressions as follows:

f1 : Column
f2 : Column
f3 : Column
g1 : AggregateExpression (Deps: f1)
g2 : AggregateExpression (Deps: f2)
h1 : SimpleExpression (Deps: g1, g2, f3)

The request is thus "give me h1":

    SimpleExpression (h1) - A dependency tree:
        (+)
        / \
      g1  (/)
          / \
         g2  f3

    Materializes to:
        SELECT g1 + (g2 / f3) FROM ...

We now move up to the parent CTE.

    AggregateExpression (g1) - An aggregate function and list of fields.
        Aggregate (SUM)
        Deps (f1)
        Group By: f3

    AggregateExpression (g2) - An aggregate function and list of fields.
        Aggregate (AVG)
        Deps (f2)
        Group By: f3

We now move up to the parent CTE:

    Column (f1)
    Column (f2)
    Column (f3)

And optionally a filter at each level.

Notes:
   When group by clauses for each query differ, need a join and two separate CTEs.
   For joins, need a join key, possibly surrogate.
   Possibly represent CTE as intermediate object.
   Start with simple case and move forward.

Query builder:
   Should accept a list of columns and expressions, and goal is to output
   these.

Alternatively, we have the notion of a base table, and can pivot on
various fields, with default aggregation at each level.

Consider

A  B  C  D  E  F
-  -  -  -  -  -
a  b  c  1  2  3
a  b  d  4  5  6
a  b  d  7  8  9

A, B, and C are pivotable, others are aggregate.
Aggregates have default aggregation functions.

Let's assume D is SUM, E is AVG, and F is COUNT DISTINCT.

If we pivot (summarize) to A, we get:

A  B  C  D  E  F
-  -  -  -  -  -
a  b  *  12 5  3

If we pivot to <A,B,C>, we get:

A  B  C  D  E   F
-  -  -  -  -   -
a  b  c  1  2   1  
a  b  d  11 6.5 2

And extended, of course, we get the values above.  (Aggregates no longer apply.)

   
